# -*- coding: utf-8 -*-
"""RL MNIST Counter.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16HeF1VJjM_7iMAYS24JY2Fq1aJ5ah6GS

## Requirements
"""

import numpy as np
import matplotlib.pyplot as plt
from keras import models, layers, optimizers, datasets, backend, utils
from tqdm.notebook import tqdm, trange
import matplotlib.pyplot as plt

"""## Environment Class"""

class Environment:
  def __init__(self, s_map, start_s):
    self.curr_s = start_s
    self.s_map = s_map

  def tau(self, s,a):
    if not (self.curr_s == 0 or self.curr_s == 9):
      s = self.s_map[self.curr_s + a][np.random.randint(len(self.s_map[self.curr_s + a]))]
      self.curr_s = self.curr_s + a
    return s

  def rho(self, a=0):
      if self.curr_s + a == 0:
        return 1
      elif self.curr_s + a == 9:
        return 2
      else:
        return 0

  def terminal_state(self, a=0):
    if self.curr_s + a == 0 or self.curr_s + a == 9:
      return True
    else:
      return False

"""## Network Classes"""

class ImageNetwork:
  def __init__(self, lr=0.0005):
    self.model = models.Sequential()
    self.layer_0 = layers.Dense(100, input_shape=(X_train.shape[1],))
    self.layer_1 = layers.Dense(64, input_shape=(100,), activation='sigmoid')
    self.layer_2 = layers.Dense(64, input_shape=(64,), activation='sigmoid')
    self.layer_3 = layers.Dense(10, input_shape=(64,), activation='sigmoid')
    self.layer_4 = layers.Dense(10, input_shape=(10,), activation='softmax')
    self.model.add(self.layer_0)
    self.model.add(self.layer_1)
    self.model.add(self.layer_2)
    self.model.add(self.layer_3)
    self.model.add(self.layer_4)
    self.model.compile(loss='sparse_categorical_crossentropy', optimizer=optimizers.Adam(lr=lr), metrics=['accuracy'])

  def fit(self, X_train, y_train, epoch=5):
    self.model.fit(X_train, y_train, epochs=epoch, verbose=1, shuffle=True)

  def predict(self, x):
    pred = self.model.predict(np.array(x))
    if pred.ndim > 1:
      for i in range(0, len(pred)):
        pred[i] = self.normalize_one_hot(pred[i])
    else:
      pred = self.normalize_one_hot(pred)
    return pred

  def get_weights(self):
    return self.model.get_weights() 

  def normalize_one_hot(self, pred):
    pred = pred
    index = np.where(pred == max(pred))
    norm_pred = np.zeros(len(pred))
    norm_pred[index] = 1
    return norm_pred

class CountingNetwork:
  #lr changed from 0.01
  def __init__(self, image_weights, s_map, gamma=0.5, invT=1, lr=0.001):
    self.image_weights = image_weights
    self.s_map = s_map
    self.gamma = gamma
    self.invT = invT
    self.lr = lr

    # Defining image classification part of network
    self.model = models.Sequential()
    self.layer_0 = layers.Dense(100, input_shape=(X_train.shape[1],))
    self.layer_1 = layers.Dense(64, input_shape=(100,), activation='sigmoid')
    self.layer_2 = layers.Dense(64, input_shape=(64,), activation='sigmoid')
    self.layer_3 = layers.Dense(10, input_shape=(64,), activation='sigmoid')
    self.layer_4 = layers.Dense(10, input_shape=(10,), activation='softmax')
    self.model.add(self.layer_0)
    self.model.add(self.layer_1)
    self.model.add(self.layer_2)
    self.model.add(self.layer_3)
    self.model.add(self.layer_4)

    if(self.image_weights != 0):
      self.model.set_weights(self.image_weights)

    # Define counting network
    self.model.add(layers.Dense(10, input_shape=(10,), activation='relu'))
    self.model.add(layers.Dense(2, input_shape=(10,), activation='linear'))

    self.compile_model()
    self.image_layers = [self.layer_0, self.layer_1, self.layer_2, self.layer_3, self.layer_4]

  def compile_model(self):
    self.model.compile(loss='mse', optimizer=optimizers.Adam(lr=self.lr))
  
  def freeze_image_layers(self, layers):
    for i in range(0, len(layers)):
      if layers[i] == 1:
        self.image_layers[i].trainable = False;
    self.compile_model();

  def freeze_model(self):
    for layer in self.image_layers:
      layer.trainable = False
    self.compile_model();

  def unfreeze_model(self):
    for layer in self.image_layers:
      layer.trainable = True
    self.compile_model();

  def fit(self, trials=400):
    nines_hit = 0
    zeros_hit = 0
    tot_reward = 0
    
    reward_vec = np.array([])
    nines_vec = np.array([])
    zeros_vec = np.array([])

    for i in trange(0, trials):
      s = self.s_map[4][np.random.randint(len(self.s_map[4]))]
      env = Environment(s_map, start_s = 4)
      # Training RL side of network
      for t in range(0,10):
        if env.terminal_state():
          if env.rho() == 1:
            zeros_hit += 1
          if env.rho() == 2:
            nines_hit += 1
          tot_reward += env.rho()
          break
        if i > 30 and self.invT > 0.1: self.invT -= 0.001
        prediction=self.model.predict(s.reshape(1,784), steps=1, verbose=0)
        aidx=np.argmax(prediction)
        if np.random.rand() < self.invT : aidx=1-aidx
        a=2*aidx-1
        next_s = env.tau(s.reshape(1,784),a)
        if env.terminal_state(a=a): 
            y = env.rho(a=a)
        else:
            y = self.gamma*np.max(self.model.predict(next_s.reshape(1,784), steps=1, verbose=0))
        prediction[0,aidx]=y
        self.model.fit(s.reshape(1,784), prediction, epochs=1, verbose=0)
        s = np.copy(next_s)
      reward_vec = np.append(reward_vec, tot_reward)
      nines_vec = np.append(nines_vec, nines_hit)
      zeros_vec = np.append(zeros_vec, zeros_hit)
    print("Total terminals reached: ", zeros_hit + nines_hit, "/", trials)
    print("Total reward: ", tot_reward)
    plt.plot(range(1, trials + 1), reward_vec, label='Total Reward')
    plt.plot(range(len(zeros_vec)), zeros_vec, label='Zeros Reached')
    plt.plot(range(len(nines_vec)), nines_vec, label='Nines Reached')
    plt.ylabel('Rewards')
    plt.xlabel('trial')
    plt.legend(loc='best')
    plt.grid()
    plt.show()

  def generate_policies(self):
    policy = np.zeros(10)
    Q=[]
    for i in range(0,10):
        Qs=self.model.predict(s_map[i][np.random.randint(len(self.s_map[i]))].reshape(1,784), steps=1)
        Q.append(Qs)
        aidx=np.argmax(Qs)
        if i == 0 or i == 9:
          policy[i] = 0
        else:
          policy[i]=2*aidx-1

    print('Q values:', np.transpose(Q))
    print('policy:',np.transpose(policy))

"""## Data & Weight Preparation"""

# Get MNIST data
(X_train, y_train), (X_test, y_test) = datasets.mnist.load_data()

# Separate training and validation data
X_train = X_train.astype(float) / 255.
X_test = X_test.astype(float) / 255.
X_train, X_val = X_train[:-10000], X_train[-10000:]
y_train, y_val = y_train[:-10000], y_train[-10000:]
    
# Flattening image 
X_train = X_train.reshape([X_train.shape[0], -1])
X_val = X_val.reshape([X_val.shape[0], -1])
X_test = X_test.reshape([X_test.shape[0], -1])

# Indexing state map
s_map = [[],[],[],[],[],[],[],[],[],[]]
for i in range(0, X_train.shape[0]):
  s_map[y_train[i]].append(X_train[i])

# Creating network instance
pretrained_network = ImageNetwork()

print("pretraininig classifier network")
pretrained_network.fit(X_train, y_train, epoch=5)
pred_image = pretrained_network.predict(X_test)
# test acc for pretrained portion of network
pred_dig = []
for i in range(0, len(pred_image)):
  pred_dig = np.append(pred_dig, np.where(pred_image[i] == max(pred_image[i])))

test_acc = np.mean(pred_dig==y_test)
print("Classification test acc.", test_acc)

"""## Frozen Pre-trained Network"""

print("Frozen")
rl_network = CountingNetwork(pretrained_network.get_weights(), s_map, gamma=0.8)
rl_network.freeze_model()
rl_network.fit(trials=400)
rl_network.generate_policies()

"""## Layer 4 Unfrozen"""

print("Layer 4 Unfrozen")
rl_network = CountingNetwork(pretrained_network.get_weights(), s_map, gamma=0.8)
rl_network.freeze_image_layers([1,1,1,1,0])
rl_network.fit(trials=400)
rl_network.generate_policies()

"""## Layer 3-4 Unfrozen"""

print("Layer 3-4 Unfrozen")
rl_network = CountingNetwork(pretrained_network.get_weights(), s_map, gamma=0.8)
rl_network.freeze_image_layers([1,1,1,0,0])
rl_network.fit(trials=400)
rl_network.generate_policies()

"""## Layer 2-4 Unfrozen"""

print("Layer 2-4 Unfrozen")
rl_network = CountingNetwork(pretrained_network.get_weights(), s_map, gamma=0.8)
rl_network.freeze_image_layers([1,1,0,0,0])
rl_network.fit(trials=400)
rl_network.generate_policies()

"""## Layer 1-4 Unfrozen"""

print("Layer 1-4 Unfrozen")
rl_network = CountingNetwork(pretrained_network.get_weights(), s_map, gamma=0.8)
rl_network.freeze_image_layers([1,0,0,0,0])
rl_network.fit(trials=400)
rl_network.generate_policies()

"""## Fully Unfrozen"""

# Unfrozen
print("Unfrozen")
rl_network = CountingNetwork(pretrained_network.get_weights(), s_map, gamma=0.8)
rl_network.fit(trials=400)
rl_network.generate_policies()

"""## Untrained"""

# Unfrozen
print("Untrained")
rl_network = CountingNetwork(0, s_map, gamma=0.8)
rl_network.fit(trials=400)
rl_network.generate_policies()